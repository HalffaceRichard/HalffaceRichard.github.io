<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>shiroLearn</title>
    <link href="/2021/08/05/shiroLearn/"/>
    <url>/2021/08/05/shiroLearn/</url>
    
    <content type="html"><![CDATA[<h3 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h3><h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><ul><li>权限管理：实现<code>对用户访问系统的控制</code>，控制用户可以访问而且只能访问自己被授权的资源。权限管理包括用户<code>身份认证</code>和<code>授权</code>两部分，简称<code>认证授权</code>。对于需要访问控制的资源用户首先经过身份认证，认证通过后用户具有该资源的访问权限方可访问。</li><li>身份认证：就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确。</li><li>授权：<code>授权，即访问控制</code>，控制谁能访问哪些资源。</li></ul><h4 id="shiro的核心架构"><a href="#shiro的核心架构" class="headerlink" title="shiro的核心架构"></a>shiro的核心架构</h4><p><img src="/img/DetailedShiro.PNG" alt="Image text"></p><h5 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h5><ul><li><code>Subject即主体</code>，外部应用与subject进行交互，subject记录了当前操作用户，将用户的概念理解为当前操作的主体，可能是一个通过浏览器请求的用户，也可能是一个运行的程序。    Subject在shiro中是一个接口，接口中定义了很多认证授相关的方法，外部程序通过subject进行认证授，而subject是通过SecurityManager安全管理器进行认证授权</li></ul><h5 id="SecurityManager"><a href="#SecurityManager" class="headerlink" title="SecurityManager"></a>SecurityManager</h5><ul><li><code>SecurityManager即安全管理器</code>，对全部的subject进行安全管理，它是shiro的核心，负责对所有的subject进行安全管理。通过SecurityManager可以完成subject的认证、授权等，实质上SecurityManager是通过Authenticator进行认证，通过Authorizer进行授权，通过SessionManager进行会话管理等。</li><li><code>SecurityManager是一个接口，继承了Authenticator, Authorizer, SessionManager这三个接口。</code></li></ul><h5 id="Authenticator"><a href="#Authenticator" class="headerlink" title="Authenticator"></a>Authenticator</h5><ul><li><code>Authenticator即认证器</code>，对用户身份进行认证，Authenticator是一个接口，shiro提供ModularRealmAuthenticator实现类，通过ModularRealmAuthenticator基本上可以满足大多数需求，也可以自定义认证器。</li></ul><h5 id="Authorizer"><a href="#Authorizer" class="headerlink" title="Authorizer"></a>Authorizer</h5><ul><li><code>Authorizer即授权器</code>，用户通过认证器认证通过，在访问功能时需要通过授权器判断用户是否有此功能的操作权限。</li></ul><h5 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h5><ul><li><code>Realm即领域</code>，相当于datasource数据源，securityManager进行安全认证需要通过Realm获取用户权限数据，比如：如果用户身份数据在数据库那么realm就需要从数据库获取用户身份信息。</li><li>注意：不要把realm理解成只是从数据源取数据，在realm中还有认证授权校验的相关的代码</li></ul><h5 id="SessionManager"><a href="#SessionManager" class="headerlink" title="SessionManager"></a>SessionManager</h5><ul><li><code>sessionManager即会话管理</code>，shiro框架定义了一套会话管理，它不依赖web容器的session，所以shiro可以使用在非web应用上，也可以将分布式应用的会话集中在一点管理，此特性可使它实现单点登录。</li></ul><h5 id="SessionDAO"><a href="#SessionDAO" class="headerlink" title="SessionDAO"></a>SessionDAO</h5><ul><li><code>SessionDAO即会话dao</code>，是对session会话操作的一套接口，比如要将session存储到数据库，可以通过jdbc将会话存储到数据库。</li></ul><h5 id="CacheManager"><a href="#CacheManager" class="headerlink" title="CacheManager"></a>CacheManager</h5><ul><li><code>CacheManager即缓存管理</code>，将用户权限数据存储在缓存，这样可以提高性能。</li></ul><h5 id="Cryptography"><a href="#Cryptography" class="headerlink" title="Cryptography"></a>Cryptography</h5><ul><li><code>Cryptography即密码管理</code>，shiro提供了一套加密/解密的组件，方便开发。比如提供常用的散列、加/解密等功能。</li></ul><h4 id="shiro中的认证"><a href="#shiro中的认证" class="headerlink" title="shiro中的认证"></a>shiro中的认证</h4><h5 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h5><ul><li>身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确。</li></ul><h5 id="shiro中认证的关键对象"><a href="#shiro中认证的关键对象" class="headerlink" title="shiro中认证的关键对象"></a>shiro中认证的关键对象</h5><ul><li>Subject：主体<ul><li>访问系统的用户，主体可以是用户、程序等，进行认证的都称为主体； </li></ul></li><li>Principal：身份信息<ul><li>是主体（subject）进行身份认证的标识，标识必须具有<code>唯一性</code>，如用户名、手机号、邮箱地址等，一个主体可以有多个身份，但是必须有一个主身份（Primary Principal）。</li></ul></li><li>credential：凭证信息<ul><li>是只有主体自己知道的安全信息，如密码、证书等。</li></ul></li></ul><h5 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h5><p><img src="/img/shiro%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B.PNG" alt="Image text"></p><h5 id="认证的开发"><a href="#认证的开发" class="headerlink" title="认证的开发"></a>认证的开发</h5><ol><li>创建项目并引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>引入shiro配置文件并加入如下配置（整合springboot后不需要）</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[users]</span><br><span class="hljs-attr">xiaochen</span>=<span class="hljs-number">123</span><br><span class="hljs-attr">zhangsan</span>=<span class="hljs-number">456</span><br></code></pre></td></tr></table></figure><ol start="3"><li>开发认证代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestAuthenticator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建securityManager</span><br>        DefaultSecurityManager defaultSecurityManager = <span class="hljs-keyword">new</span> DefaultSecurityManager();<br>        defaultSecurityManager.setRealm(<span class="hljs-keyword">new</span> IniRealm(<span class="hljs-string">&quot;classpath:shiro.ini&quot;</span>));<br>        <span class="hljs-comment">//将安装工具类中设置默认安全管理器</span><br>        SecurityUtils.setSecurityManager(defaultSecurityManager);<br>        <span class="hljs-comment">//获取主体对象</span><br>        Subject subject = SecurityUtils.getSubject();<br>        <span class="hljs-comment">//创建token令牌</span><br>        UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(<span class="hljs-string">&quot;xiaochen1&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            subject.login(token);<span class="hljs-comment">//用户登录</span><br>            System.out.println(<span class="hljs-string">&quot;登录成功~~&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (UnknownAccountException e) &#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;用户名错误!!&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (IncorrectCredentialsException e)&#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;密码错误!!!&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><ul><li><p>DisabledAccountException（帐号被禁用）</p></li><li><p>LockedAccountException（帐号被锁定）</p></li><li><p>ExcessiveAttemptsException（登录失败次数过多）</p></li><li><p>ExpiredCredentialsException（凭证过期）等</p></li></ul><h5 id="自定义Realm"><a href="#自定义Realm" class="headerlink" title="自定义Realm"></a>自定义Realm</h5><ul><li>上边的程序使用的是Shiro自带的IniRealm，IniRealm从ini配置文件中读取用户的信息，大部分情况下需要从系统的数据库中读取用户信息，所以需要自定义realm。</li></ul><ol><li><p>shiro提供的Realm。其中AuthenticatingRealm是做认证的Realm，方法是doGetAuthenticationInfo；AuthorizingRealm是做授权的Reamlm，方法是doGetAuthorizationInfo</p></li><li><p>根据认证源码认证使用的是SimpleAccountRealm中的doGetAuthenticationInfo方法中完成用户名校验。最终密码校验是在AuthenticatingRealm中的assertCredentialsMatch方法中完成</p></li></ol><ul><li><code>SimpleAccountRealm的部分源码中有两个方法一个是 认证 一个是 授权</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleAccountRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;<br><span class="hljs-comment">//.......省略</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;<br>        UsernamePasswordToken upToken = (UsernamePasswordToken) token;<br>        SimpleAccount account = getUser(upToken.getUsername());<br><br>        <span class="hljs-keyword">if</span> (account != <span class="hljs-keyword">null</span>) &#123;<br><br>            <span class="hljs-keyword">if</span> (account.isLocked()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> LockedAccountException(<span class="hljs-string">&quot;Account [&quot;</span> + account + <span class="hljs-string">&quot;] is locked.&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (account.isCredentialsExpired()) &#123;<br>                String msg = <span class="hljs-string">&quot;The credentials for account [&quot;</span> + account + <span class="hljs-string">&quot;] are expired&quot;</span>;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ExpiredCredentialsException(msg);<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> account;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principals)</span> </span>&#123;<br>        String username = getUsername(principals);<br>        USERS_LOCK.readLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.users.get(username);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            USERS_LOCK.readLock().unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>自定义realm</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;<br>    <span class="hljs-comment">//授权</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principals)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;==================&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//认证</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;<br>        <span class="hljs-comment">//在token中获取用户名</span><br>        String principal = (String) token.getPrincipal();<br>        System.out.println(principal);<br>        <span class="hljs-comment">//根据身份信息使用jdbc mybatis查询相关数据库</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;xiaochen&quot;</span>.equals(principal))&#123;<br>            <span class="hljs-comment">//参数1:返回数据库中正确的用户名   //参数2:返回数据库中正确密码  //参数3:提供当前realm的名字 this.getName();</span><br>            SimpleAuthenticationInfo simpleAuthenticationInfo = <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(principal,<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-keyword">this</span>.getName());<br>            <span class="hljs-keyword">return</span> simpleAuthenticationInfo;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>使用自定义Realm认证</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestAuthenticatorCusttomerRealm</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建securityManager</span><br>        DefaultSecurityManager defaultSecurityManager = <span class="hljs-keyword">new</span> DefaultSecurityManager();<br>        <span class="hljs-comment">//IniRealm realm = new IniRealm(&quot;classpath:shiro.ini&quot;);</span><br>        <span class="hljs-comment">//设置为自定义realm获取认证数据</span><br>        defaultSecurityManager.setRealm(<span class="hljs-keyword">new</span> CustomerRealm());<br>        <span class="hljs-comment">//将安装工具类中设置默认安全管理器</span><br>        SecurityUtils.setSecurityManager(defaultSecurityManager);<br>        <span class="hljs-comment">//获取主体对象</span><br>        Subject subject = SecurityUtils.getSubject();<br>        <span class="hljs-comment">//创建token令牌</span><br>        UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(<span class="hljs-string">&quot;xiaochen&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            subject.login(token);<span class="hljs-comment">//用户登录</span><br>            System.out.println(<span class="hljs-string">&quot;登录成功~~&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (UnknownAccountException e) &#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;用户名错误!!&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (IncorrectCredentialsException e)&#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;密码错误!!!&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="使用MD5和Salt"><a href="#使用MD5和Salt" class="headerlink" title="使用MD5和Salt"></a>使用MD5和Salt</h5><ul><li>实际应用是将盐和散列后的值存在数据库中，自动realm从数据库取出盐和加密后的值由shiro完成密码校验。</li><li>MD5算法不可逆，而且结果始终一致，是一个16进制的32位长度字符串。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestShiroMD5</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//创建一个md5算法</span><br><span class="hljs-comment">//        Md5Hash md5Hash = new Md5Hash();</span><br><span class="hljs-comment">//        md5Hash.setBytes(&quot;123&quot;.getBytes());</span><br><span class="hljs-comment">//        String s = md5Hash.toHex();</span><br><span class="hljs-comment">//        System.out.println(s);</span><br><br>        <span class="hljs-comment">//使用md5</span><br>        Md5Hash md5Hash = <span class="hljs-keyword">new</span> Md5Hash(<span class="hljs-string">&quot;123&quot;</span>);<br><br>        System.out.println(md5Hash.toHex());<br><br>        <span class="hljs-comment">//使用MD5 + salt处理</span><br>        Md5Hash md5Hash1 = <span class="hljs-keyword">new</span> Md5Hash(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;X0*7ps&quot;</span>);<br><br>        System.out.println(md5Hash1.toHex());<br><br>        <span class="hljs-comment">//使用md5 + salt + hash散列</span><br>        Md5Hash md5Hash2 = <span class="hljs-keyword">new</span> Md5Hash(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;X0*7ps&quot;</span>, <span class="hljs-number">1024</span>);<br>        System.out.println(md5Hash2.toHex());<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用自定义realm 加入md5 + salt +hash</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerMd5Realm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;<br><br>    <span class="hljs-comment">//授权</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principals)</span> </span>&#123;<br>        String primaryPrincipal = (String) principals.getPrimaryPrincipal();<br>        System.out.println(<span class="hljs-string">&quot;身份信息: &quot;</span>+primaryPrincipal);<br><br>        <span class="hljs-comment">//根据身份信息 用户名 获取当前用户的角色信息,以及权限信息  xiaochen  admin user</span><br>        SimpleAuthorizationInfo simpleAuthorizationInfo = <span class="hljs-keyword">new</span> SimpleAuthorizationInfo();<br><br>        <span class="hljs-comment">//将数据库中查询角色信息赋值给权限对象</span><br>        simpleAuthorizationInfo.addRole(<span class="hljs-string">&quot;admin&quot;</span>);<br>        simpleAuthorizationInfo.addRole(<span class="hljs-string">&quot;user&quot;</span>);<br><br>        <span class="hljs-comment">//将数据库中查询权限信息赋值个权限对象</span><br>        simpleAuthorizationInfo.addStringPermission(<span class="hljs-string">&quot;user:*:01&quot;</span>);<br>        simpleAuthorizationInfo.addStringPermission(<span class="hljs-string">&quot;product:create&quot;</span>);<br><br><br>        <span class="hljs-keyword">return</span> simpleAuthorizationInfo;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;<br>        <span class="hljs-comment">//获取身份信息</span><br>        String principal = (String) token.getPrincipal();<br><br>        <span class="hljs-comment">//根据用户名查询数据库</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;xiaochen&quot;</span>.equals(principal)) &#123;<br>            <span class="hljs-comment">//参数1: 数据库用户名  参数2:数据库md5+salt之后的密码  参数3:注册时散列后的随机盐  参数4:realm的名字</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(principal,<br>                    <span class="hljs-string">&quot;e4f9bf3e0c58f045e62c23c533fcf633&quot;</span>,<br>                    ByteSource.Util.bytes(<span class="hljs-string">&quot;X0*7ps&quot;</span>),<br>                    <span class="hljs-keyword">this</span>.getName());<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCustomerMd5RealmAuthenicator</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//创建安全管理器</span><br>        DefaultSecurityManager defaultSecurityManager = <span class="hljs-keyword">new</span> DefaultSecurityManager();<br>        <span class="hljs-comment">//注入realm</span><br>        CustomerMd5Realm realm = <span class="hljs-keyword">new</span> CustomerMd5Realm();<br>        <span class="hljs-comment">//设置realm使用hash凭证匹配器</span><br><br>        HashedCredentialsMatcher credentialsMatcher = <span class="hljs-keyword">new</span> HashedCredentialsMatcher();<br>        <span class="hljs-comment">//使用算法</span><br>        credentialsMatcher.setHashAlgorithmName(<span class="hljs-string">&quot;md5&quot;</span>);<br>        <span class="hljs-comment">//散列次数</span><br>        credentialsMatcher.setHashIterations(<span class="hljs-number">1024</span>);<br>        realm.setCredentialsMatcher(credentialsMatcher);<br><br>        defaultSecurityManager.setRealm(realm);<br>        <span class="hljs-comment">//将安全管理器注入安全工具</span><br>        SecurityUtils.setSecurityManager(defaultSecurityManager);<br><br>        <span class="hljs-comment">//通过安全工具类获取subject</span><br>        Subject subject = SecurityUtils.getSubject();<br><br>        <span class="hljs-comment">//认证</span><br>        UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(<span class="hljs-string">&quot;xiaochen&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            subject.login(token);<br>            System.out.println(<span class="hljs-string">&quot;登录成功&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (UnknownAccountException e) &#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;用户名错误&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (IncorrectCredentialsException e)&#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;密码错误&quot;</span>);<br>        &#125;<br><br><br>        <span class="hljs-comment">//授权</span><br>        <span class="hljs-keyword">if</span>(subject.isAuthenticated())&#123;<br><br>            <span class="hljs-comment">//基于角色权限控制</span><br>            System.out.println(subject.hasRole(<span class="hljs-string">&quot;admin&quot;</span>));<br><br>            <span class="hljs-comment">//基于多角色权限控制</span><br>            System.out.println(subject.hasAllRoles(Arrays.asList(<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;super&quot;</span>)));<br><br>            <span class="hljs-comment">//是否具有其中一个角色</span><br>            <span class="hljs-keyword">boolean</span>[] booleans = subject.hasRoles(Arrays.asList(<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;super&quot;</span>, <span class="hljs-string">&quot;user&quot;</span>));<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">boolean</span> aBoolean : booleans) &#123;<br>                System.out.println(aBoolean);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;==============================================&quot;</span>);<br><br>            <span class="hljs-comment">//基于权限字符串的访问控制  资源标识符:操作:资源类型</span><br>            System.out.println(<span class="hljs-string">&quot;权限:&quot;</span>+subject.isPermitted(<span class="hljs-string">&quot;user:update:01&quot;</span>));<br>            System.out.println(<span class="hljs-string">&quot;权限:&quot;</span>+subject.isPermitted(<span class="hljs-string">&quot;product:create:02&quot;</span>));<br><br>            <span class="hljs-comment">//分别具有那些权限</span><br>            <span class="hljs-keyword">boolean</span>[] permitted = subject.isPermitted(<span class="hljs-string">&quot;user:*:01&quot;</span>, <span class="hljs-string">&quot;order:*:10&quot;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">boolean</span> b : permitted) &#123;<br>                System.out.println(b);<br>            &#125;<br><br>            <span class="hljs-comment">//同时具有哪些权限</span><br>            <span class="hljs-keyword">boolean</span> permittedAll = subject.isPermittedAll(<span class="hljs-string">&quot;user:*:01&quot;</span>, <span class="hljs-string">&quot;product:create:01&quot;</span>);<br>            System.out.println(permittedAll);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="shiro中的授权（代码见上-授权）"><a href="#shiro中的授权（代码见上-授权）" class="headerlink" title="shiro中的授权（代码见上//授权）"></a>shiro中的授权（代码见上//授权）</h4><ul><li><p>授权，即访问控制，控制谁能访问哪些资源。主体进行身份认证后需要分配权限方可访问系统的资源，对于某些资源没有权限是无法访问的。</p></li><li><p><strong>授权可简单理解为who对what(which)进行How操作：</strong></p><ul><li><code>Who，即主体（Subject）</code>，主体需要访问系统中的资源。</li><li><code>What，即资源（Resource)</code>，如系统菜单、页面、按钮、类方法、系统商品信息等。资源包括<code>资源类型</code>和<code>资源实例</code>，比如<code>商品信息为资源类型</code>，类型为t01的商品为<code>资源实例</code>，编号为001的商品信息也属于资源实例。</li><li><code>How，权限/许可（Permission)</code>，规定了主体对资源的操作许可，权限离开资源没有意义，如用户查询权限、用户添加权限、某个类方法的调用权限、编号为001用户的修改权限等，通过权限可知主体对哪些资源都有哪些操作许可。</li></ul></li><li><p>授权方式：</p><ul><li><p>RBAC基于角色的访问控制（Role-Based Access Control）是以角色为中心进行访问控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(subject.hasRole(<span class="hljs-string">&quot;admin&quot;</span>))&#123;<br>   <span class="hljs-comment">//操作什么资源</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>RBAC基于资源的访问控制（Resource-Based Access Control）是以资源为中心进行访问控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(subject.isPermission(<span class="hljs-string">&quot;user:update:01&quot;</span>))&#123; <span class="hljs-comment">//资源实例</span><br>  <span class="hljs-comment">//对01用户进行修改</span><br>&#125;<br><span class="hljs-keyword">if</span>(subject.isPermission(<span class="hljs-string">&quot;user:update:*&quot;</span>))&#123;  <span class="hljs-comment">//资源类型</span><br>  <span class="hljs-comment">//对01用户进行修改</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>权限字符串：权限字符串的规则是：<strong>资源标识符：操作：资源实例标识符</strong>，意思是对哪个资源的哪个实例具有什么操作，“:”是资源/操作/实例的分割符，权限字符串也可以使用*通配符。</p><ul><li>例子：<ul><li>用户创建权限：user:create，或user:create:*</li><li>用户修改实例001的权限：user:update:001</li><li>用户实例001的所有权限：user:*：001</li></ul></li></ul></li><li><p>shiro中授权编程实现方式：</p><ul><li><strong>编程式</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Subject subject = SecurityUtils.getSubject();<br><span class="hljs-keyword">if</span>(subject.hasRole(“admin”)) &#123;<br><span class="hljs-comment">//有权限</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//无权限</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>注解式</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequiresRoles(&quot;admin&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//有权限</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>标签式</strong></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsp">JSP/GSP 标签：在JSP/GSP 页面通过相应的标签完成：<br>&lt;shiro:hasRole name=<span class="hljs-string">&quot;admin&quot;</span>&gt;<br>&lt;!— 有权限—&gt;<br>&lt;/shiro:hasRole&gt;<br>注意: Thymeleaf 中使用shiro需要额外集成!<br></code></pre></td></tr></table></figure></li></ul><h4 id="整合SpringBoot实战（关键部分代码）"><a href="#整合SpringBoot实战（关键部分代码）" class="headerlink" title="整合SpringBoot实战（关键部分代码）"></a>整合SpringBoot实战（关键部分代码）</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用来整合shiro框架相关的配置类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShiroConfig</span> </span>&#123;<br><br><br>    <span class="hljs-comment">//1.创建shiroFilter  //负责拦截所有请求</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ShiroFilterFactoryBean <span class="hljs-title">getShiroFilterFactoryBean</span><span class="hljs-params">(DefaultWebSecurityManager defaultWebSecurityManager)</span></span>&#123;<br>        ShiroFilterFactoryBean shiroFilterFactoryBean = <span class="hljs-keyword">new</span> ShiroFilterFactoryBean();<br><br>        <span class="hljs-comment">//给filter设置安全管理器</span><br>        shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager);<br><br>        <span class="hljs-comment">//配置系统受限资源</span><br>        <span class="hljs-comment">//配置系统公共资源</span><br>        Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String,String&gt;();<br>        map.put(<span class="hljs-string">&quot;/user/login&quot;</span>,<span class="hljs-string">&quot;anon&quot;</span>);<span class="hljs-comment">//anon 设置为公共资源  放行资源放在下面</span><br>        map.put(<span class="hljs-string">&quot;/user/register&quot;</span>,<span class="hljs-string">&quot;anon&quot;</span>);<span class="hljs-comment">//anon 设置为公共资源  放行资源放在下面</span><br>        map.put(<span class="hljs-string">&quot;/register.jsp&quot;</span>,<span class="hljs-string">&quot;anon&quot;</span>);<span class="hljs-comment">//anon 设置为公共资源  放行资源放在下面</span><br>        map.put(<span class="hljs-string">&quot;/user/getImage&quot;</span>,<span class="hljs-string">&quot;anon&quot;</span>);<br><br>        map.put(<span class="hljs-string">&quot;/**&quot;</span>,<span class="hljs-string">&quot;authc&quot;</span>);<span class="hljs-comment">//authc 请求这个资源需要认证和授权</span><br><br>        <span class="hljs-comment">//默认认证界面路径</span><br>        shiroFilterFactoryBean.setLoginUrl(<span class="hljs-string">&quot;/login.jsp&quot;</span>);<br>        shiroFilterFactoryBean.setFilterChainDefinitionMap(map);<br><br><br>        <span class="hljs-keyword">return</span> shiroFilterFactoryBean;<br>    &#125;<br><br>    <span class="hljs-comment">//2.创建安全管理器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DefaultWebSecurityManager <span class="hljs-title">getDefaultWebSecurityManager</span><span class="hljs-params">(Realm realm)</span></span>&#123;<br>        DefaultWebSecurityManager defaultWebSecurityManager = <span class="hljs-keyword">new</span> DefaultWebSecurityManager();<br>        <span class="hljs-comment">//给安全管理器设置</span><br>        defaultWebSecurityManager.setRealm(realm);<br><br>        <span class="hljs-keyword">return</span> defaultWebSecurityManager;<br>    &#125;<br><br>    <span class="hljs-comment">//3.创建自定义realm</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Realm <span class="hljs-title">getRealm</span><span class="hljs-params">()</span></span>&#123;<br>        CustomerRealm customerRealm = <span class="hljs-keyword">new</span> CustomerRealm();<br><br>        <span class="hljs-comment">//修改凭证校验匹配器</span><br>        HashedCredentialsMatcher credentialsMatcher = <span class="hljs-keyword">new</span> HashedCredentialsMatcher();<br>        <span class="hljs-comment">//设置加密算法为md5</span><br>        credentialsMatcher.setHashAlgorithmName(<span class="hljs-string">&quot;MD5&quot;</span>);<br>        <span class="hljs-comment">//设置散列次数</span><br>        credentialsMatcher.setHashIterations(<span class="hljs-number">1024</span>);<br>        customerRealm.setCredentialsMatcher(credentialsMatcher);<br><br><br>        <span class="hljs-comment">//开启缓存管理</span><br>        customerRealm.setCacheManager(<span class="hljs-keyword">new</span> RedisCacheManager());<br>        customerRealm.setCachingEnabled(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//开启全局缓存</span><br>        customerRealm.setAuthenticationCachingEnabled(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//认证认证缓存</span><br>        customerRealm.setAuthenticationCacheName(<span class="hljs-string">&quot;authenticationCache&quot;</span>);<br>        customerRealm.setAuthorizationCachingEnabled(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//开启授权缓存</span><br>        customerRealm.setAuthorizationCacheName(<span class="hljs-string">&quot;authorizationCache&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> customerRealm;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>常见过滤器</li></ul><p>注意: <strong>shiro提供和多个默认的过滤器，我们可以用这些过滤器来配置控制指定url的权限：</strong></p><table><thead><tr><th>配置缩写</th><th>对应的过滤器</th><th>功能</th></tr></thead><tbody><tr><td>anon</td><td>AnonymousFilter</td><td>指定url可以匿名访问</td></tr><tr><td>authc</td><td>FormAuthenticationFilter</td><td>指定url需要form表单登录，默认会从请求中获取<code>username</code>、<code>password</code>,<code>rememberMe</code>等参数并尝试登录，如果登录不了就会跳转到loginUrl配置的路径。我们也可以用这个过滤器做默认的登录逻辑，但是一般都是我们自己在控制器写登录逻辑的，自己写的话出错返回的信息都可以定制嘛。</td></tr><tr><td>authcBasic</td><td>BasicHttpAuthenticationFilter</td><td>指定url需要basic登录</td></tr><tr><td>logout</td><td>LogoutFilter</td><td>登出过滤器，配置指定url就可以实现退出功能，非常方便</td></tr><tr><td>noSessionCreation</td><td>NoSessionCreationFilter</td><td>禁止创建会话</td></tr><tr><td>perms</td><td>PermissionsAuthorizationFilter</td><td>需要指定权限才能访问</td></tr><tr><td>port</td><td>PortFilter</td><td>需要指定端口才能访问</td></tr><tr><td>rest</td><td>HttpMethodPermissionFilter</td><td>将http请求方法转化成相应的动词来构造一个权限字符串，这个感觉意义不大，有兴趣自己看源码的注释</td></tr><tr><td>roles</td><td>RolesAuthorizationFilter</td><td>需要指定角色才能访问</td></tr><tr><td>ssl</td><td>SslFilter</td><td>需要https请求才能访问</td></tr><tr><td>user</td><td>UserFilter</td><td>需要已登录或“记住我”的用户才能访问</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//自定义realm</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principals)</span> </span>&#123;<br>        <span class="hljs-comment">//获取身份信息</span><br>        String primaryPrincipal = (String) principals.getPrimaryPrincipal();<br>        System.out.println(<span class="hljs-string">&quot;调用授权验证: &quot;</span>+primaryPrincipal);<br>        <span class="hljs-comment">//根据主身份信息获取角色 和 权限信息</span><br>        UserService userService = (UserService) ApplicationContextUtils<br>                .getBean(<span class="hljs-string">&quot;userService&quot;</span>);<br>        User user = userService.findRolesByUserName(primaryPrincipal);<br>        <span class="hljs-comment">//授权角色信息</span><br>        <span class="hljs-keyword">if</span>(!CollectionUtils.isEmpty(user.getRoles()))&#123;<br>            SimpleAuthorizationInfo simpleAuthorizationInfo = <span class="hljs-keyword">new</span> SimpleAuthorizationInfo();<br>            user.getRoles().forEach(role-&gt;&#123;<br>                simpleAuthorizationInfo.addRole(role.getName());<br>                <span class="hljs-comment">//权限信息</span><br>                List&lt;Perms&gt; perms = userService.findPermsByRoleId(role.getId());<br>                <span class="hljs-keyword">if</span>(!CollectionUtils.isEmpty(perms))&#123;<br>                    perms.forEach(perm-&gt;&#123;<br>                        simpleAuthorizationInfo.addStringPermission(perm.getName());<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-keyword">return</span> simpleAuthorizationInfo;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;==========================&quot;</span>);<br>        <span class="hljs-comment">//根据身份信息</span><br>        String principal = (String) token.getPrincipal();<br>        <span class="hljs-comment">//在工厂中获取service对象</span><br>        UserService userService = (UserService) ApplicationContextUtils.getBean(<span class="hljs-string">&quot;userService&quot;</span>);<br>        User user = userService.findByUserName(principal);<br>        <span class="hljs-keyword">if</span>(!ObjectUtils.isEmpty(user))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(user.getUsername(),user.getPassword(),<br>                    <span class="hljs-keyword">new</span> MyByteSource(user.getSalt()),<br>                    <span class="hljs-keyword">this</span>.getName());<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 验证码方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;getImage&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getImage</span><span class="hljs-params">(HttpSession session, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//生成验证码</span><br>        String code = VerifyCodeUtils.generateVerifyCode(<span class="hljs-number">4</span>);<br>        <span class="hljs-comment">//验证码放入session</span><br>        session.setAttribute(<span class="hljs-string">&quot;code&quot;</span>,code);<br>        <span class="hljs-comment">//验证码存入图片</span><br>        ServletOutputStream os = response.getOutputStream();<br>        response.setContentType(<span class="hljs-string">&quot;image/png&quot;</span>);<br>        VerifyCodeUtils.outputImage(<span class="hljs-number">220</span>,<span class="hljs-number">60</span>,os,code);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户注册</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;register&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">register</span><span class="hljs-params">(User user)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            userService.register(user);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/login.jsp&quot;</span>;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/register.jsp&quot;</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 退出登录</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;logout&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">logout</span><span class="hljs-params">()</span> </span>&#123;<br>        Subject subject = SecurityUtils.getSubject();<br>        subject.logout();<span class="hljs-comment">//退出用户</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/login.jsp&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用来处理身份认证</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> password</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;login&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(String username, String password,String code,HttpSession session)</span> </span>&#123;<br>        <span class="hljs-comment">//比较验证码</span><br>        String codes = (String) session.getAttribute(<span class="hljs-string">&quot;code&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (codes.equalsIgnoreCase(code))&#123;<br>                <span class="hljs-comment">//获取主体对象</span><br>                Subject subject = SecurityUtils.getSubject();<br>                    subject.login(<span class="hljs-keyword">new</span> UsernamePasswordToken(username, password));<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/index.jsp&quot;</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;验证码错误!&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (UnknownAccountException e) &#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;用户名错误!&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IncorrectCredentialsException e) &#123;<br>            e.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;密码错误!&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>            System.out.println(e.getMessage());<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/login.jsp&quot;</span>;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Service(&quot;userService&quot;)</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDAO userDAO;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Perms&gt; <span class="hljs-title">findPermsByRoleId</span><span class="hljs-params">(String id)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> userDAO.findPermsByRoleId(id);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">findRolesByUserName</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> userDAO.findRolesByUserName(username);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">findByUserName</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> userDAO.findByUserName(username);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(User user)</span> </span>&#123;<br>        <span class="hljs-comment">//处理业务调用dao</span><br>        <span class="hljs-comment">//1.生成随机盐</span><br>        String salt = SaltUtils.getSalt(<span class="hljs-number">8</span>);<br>        <span class="hljs-comment">//2.将随机盐保存到数据</span><br>        user.setSalt(salt);<br>        <span class="hljs-comment">//3.明文密码进行md5 + salt + hash散列</span><br>        Md5Hash md5Hash = <span class="hljs-keyword">new</span> Md5Hash(user.getPassword(),salt,<span class="hljs-number">1024</span>);<br>        user.setPassword(md5Hash.toHex());<br>        userDAO.save(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//自定义shiro缓存管理器</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisCacheManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CacheManager</span> </span>&#123;<br><br>    <span class="hljs-comment">//参数1:认证或者是授权缓存的统一名称</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;K, V&gt; <span class="hljs-function">Cache&lt;K, V&gt; <span class="hljs-title">getCache</span><span class="hljs-params">(String cacheName)</span> <span class="hljs-keyword">throws</span> CacheException </span>&#123;<br>        System.out.println(cacheName);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RedisCache&lt;K,V&gt;(cacheName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//自定义redis缓存的实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisCache</span>&lt;<span class="hljs-title">k</span>,<span class="hljs-title">v</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Cache</span>&lt;<span class="hljs-title">k</span>,<span class="hljs-title">v</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String cacheName;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RedisCache</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RedisCache</span><span class="hljs-params">(String cacheName)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.cacheName = cacheName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> v <span class="hljs-title">get</span><span class="hljs-params">(k k)</span> <span class="hljs-keyword">throws</span> CacheException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;get key:&quot;</span>+k);<br>        <span class="hljs-keyword">return</span> (v) getRedisTemplate().opsForHash().get(<span class="hljs-keyword">this</span>.cacheName,k.toString());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> v <span class="hljs-title">put</span><span class="hljs-params">(k k, v v)</span> <span class="hljs-keyword">throws</span> CacheException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;put key: &quot;</span>+k);<br>        System.out.println(<span class="hljs-string">&quot;put value:&quot;</span>+v);<br>        getRedisTemplate().opsForHash().put(<span class="hljs-keyword">this</span>.cacheName,k.toString(),v);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> v <span class="hljs-title">remove</span><span class="hljs-params">(k k)</span> <span class="hljs-keyword">throws</span> CacheException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;=============remove=============&quot;</span>);<br>        <span class="hljs-keyword">return</span> (v) getRedisTemplate().opsForHash().delete(<span class="hljs-keyword">this</span>.cacheName,k.toString());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CacheException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;=============clear==============&quot;</span>);<br>        getRedisTemplate().delete(<span class="hljs-keyword">this</span>.cacheName);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getRedisTemplate().opsForHash().size(<span class="hljs-keyword">this</span>.cacheName).intValue();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;k&gt; <span class="hljs-title">keys</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getRedisTemplate().opsForHash().keys(<span class="hljs-keyword">this</span>.cacheName);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;v&gt; <span class="hljs-title">values</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getRedisTemplate().opsForHash().values(<span class="hljs-keyword">this</span>.cacheName);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> RedisTemplate <span class="hljs-title">getRedisTemplate</span><span class="hljs-params">()</span></span>&#123;<br>        RedisTemplate redisTemplate = (RedisTemplate) ApplicationContextUtils.getBean(<span class="hljs-string">&quot;redisTemplate&quot;</span>);<br>        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());<br>        redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());<br>        <span class="hljs-keyword">return</span> redisTemplate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>鉴权</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shiro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>myBatis-plus复习小结</title>
    <link href="/2021/08/04/myBatis-plus%E5%A4%8D%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/08/04/myBatis-plus%E5%A4%8D%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h4 id="第一步，分析依赖"><a href="#第一步，分析依赖" class="headerlink" title="第一步，分析依赖"></a>第一步，分析依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/p1.PNG" alt="Image text"></p><p>由上图可以看到，mybatis-plus的starter里引入了mybatis和jdbc，所以不需要在依赖中再引入这些，仅仅有一个mybatis-plus足够了。</p><h4 id="第二步，分析主要源码"><a href="#第二步，分析主要源码" class="headerlink" title="第二步，分析主要源码"></a>第二步，分析主要源码</h4><h5 id="2-1-找到spring-factories"><a href="#2-1-找到spring-factories" class="headerlink" title="2.1 找到spring.factories"></a>2.1 找到spring.factories</h5><p><img src="/img/p2.PNG" alt="Image text"></p><p>由上图，在mybatis-plus-boot-starter中的META-INF里spring.factories可以看到，项目一启动，便会加载这些类。这些类位于mybatisplus.autoconfigure中。</p><h5 id="2-2-分析配置类（MybatisPlusAutoConfiguration）"><a href="#2-2-分析配置类（MybatisPlusAutoConfiguration）" class="headerlink" title="2.2 分析配置类（MybatisPlusAutoConfiguration）"></a>2.2 分析配置类（MybatisPlusAutoConfiguration）</h5><p><img src="/img/p3.PNG" alt="Image text"></p><ul><li>配置文件中的所有属性都和MybatisPlusProperties.class相绑定。</li></ul><p>点进去看一下，发现前缀prefix = Constants.MYBATIS_PLUS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@ConfigurationProperties(prefix = Constants.MYBATIS_PLUS)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisPlusProperties</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>然后又看到如下接口，用mybatis-plus:xxx来进行定制化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Constants</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StringPool</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br>    String MYBATIS_PLUS = <span class="hljs-string">&quot;mybatis-plus&quot;</span>;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>回到配置类，发现SqlSessionFactory自动配置好了，且底层是容器中默认的数据源。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">sqlSessionFactory</span><span class="hljs-params">(DataSource dataSource)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    MybatisSqlSessionFactoryBean factory = <span class="hljs-keyword">new</span> MybatisSqlSessionFactoryBean();<br>    factory.setDataSource(dataSource);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>而且，在配置类中，还有SqlSessionTemplate</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionTemplate <span class="hljs-title">sqlSessionTemplate</span><span class="hljs-params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;<br>    ExecutorType executorType = <span class="hljs-keyword">this</span>.properties.getExecutorType();<br>    <span class="hljs-keyword">if</span> (executorType != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SqlSessionTemplate(sqlSessionFactory, executorType);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SqlSessionTemplate(sqlSessionFactory);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>@Mapper 标注的接口也会被自动扫描，建议直接@MapperScan(“com.xxx.mapper”)批量扫描。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Import(AutoConfiguredMapperScannerRegistrar.class)</span><br><span class="hljs-meta">@ConditionalOnMissingBean(&#123;MapperFactoryBean.class, MapperScannerConfigurer.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapperScannerRegistrarNotFoundConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> </span>&#123;<br>        logger.debug(<br>            <span class="hljs-string">&quot;Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer.&quot;</span>);<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/p4.PNG" alt="Image text"></p><ul><li>在MybatisPlusProperties类中，mapperLocations自动配置好了，有默认值classpath*:/mapper/**/*.xml，这表示任意包的类路径下的所有mapper文件夹下任意路径下的所有xml都是sql映射文件。 建议以后sql映射文件放在 mapper下。</li></ul><blockquote><p>只需要Mapper继承MyBatisPlus的BaseMapper类就可以拥有CRUD能力。<br>public interface XXXMapper extends BaseMapper&lt;返回类型&gt;{}</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BaseMapper</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(T entity)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteById</span><span class="hljs-params">(Serializable id)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteByMap</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;cm&quot;)</span> Map&lt;String, Object&gt; columnMap)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteBatchIds</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;coll&quot;)</span> Collection&lt;? extends Serializable&gt; idList)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;et&quot;)</span> T entity)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;et&quot;)</span> T entity, <span class="hljs-meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; updateWrapper)</span></span>;<br>    <span class="hljs-function">T <span class="hljs-title">selectById</span><span class="hljs-params">(Serializable id)</span></span>;<br>    <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">selectBatchIds</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;coll&quot;)</span> Collection&lt;? extends Serializable&gt; idList)</span></span>;<br>    <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">selectByMap</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;cm&quot;)</span> Map&lt;String, Object&gt; columnMap)</span></span>;<br>    <span class="hljs-function">T <span class="hljs-title">selectOne</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span></span>;<br>    <span class="hljs-function">Integer <span class="hljs-title">selectCount</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span></span>;<br>    <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">selectList</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span></span>;<br>    List&lt;Map&lt;String, Object&gt;&gt; selectMaps(<span class="hljs-meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper);<br>    <span class="hljs-function">List&lt;Object&gt; <span class="hljs-title">selectObjs</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span></span>;<br>    &lt;E extends IPage&lt;T&gt;&gt; <span class="hljs-function">E <span class="hljs-title">selectPage</span><span class="hljs-params">(E page, <span class="hljs-meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span></span>;<br>    &lt;E extends IPage&lt;Map&lt;String, Object&gt;&gt;&gt; <span class="hljs-function">E <span class="hljs-title">selectMapsPage</span><span class="hljs-params">(E page, <span class="hljs-meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第三步，一些使用上的注意事项"><a href="#第三步，一些使用上的注意事项" class="headerlink" title="第三步，一些使用上的注意事项"></a>第三步，一些使用上的注意事项</h4><ol><li>具体在使用mybatis-plus时，要先有Service接口，然后让接口继承IService；再让接口的实现类在实现接口的同时，继承ServiceImpl类，在ServiceImpl中要注明操作的是哪个Mapper以及要返回的数据类型。</li><li>可以用@TableName(“表名”)来给pojo标注上具体连接数据库中的哪个表；</li><li>pojo中的所有属性都应该在数据库中，如果有不在的，标记上@TableField(exist=false)</li><li>关于主键生成策略：参考雪花算法，通常使用@TableId(type=IdType.ID_WORKER)注解，可以保证ID全局唯一。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@TableId(type=IdType.ID_WORKER)</span><br><span class="hljs-comment">//点开注解</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(&#123;ElementType.FIELD&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> TableId &#123;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>    <span class="hljs-function">IdType <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> IdType.NONE</span>;<br>&#125;<br><span class="hljs-comment">//查看IdType</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">IdType</span> </span>&#123;<br>    AUTO(<span class="hljs-number">0</span>),<br>    NONE(<span class="hljs-number">1</span>),<br>    INPUT(<span class="hljs-number">2</span>),<br>    ID_WORKER(<span class="hljs-number">3</span>),<br>    UUID(<span class="hljs-number">4</span>),<br>    ID_WORKER_STR(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> key;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">IdType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.key = key;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>若是主键自增，就是用@TableId(type=IdType.AUTO)，同时在数据库表中勾选主键自增。</p><ol start="5"><li>自动填充功能：实现元对象处理器接口：handlers.MetaObjectHandler。具体来说就是在pojo类里想要实现自动填充功能的属性上添加注解。然后创建XXXMetaObjectHandler类实现MetaObjectHandler接口，重写相对应的方法，利用反射找到相对应的属性名字实现自动填充功能。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@TableField(fill= FieldFill.INSERT)</span><br><span class="hljs-keyword">private</span> Date createTime;<br><span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="hljs-keyword">private</span> Date updateTime;<br><span class="hljs-comment">//</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMetaObjectHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MetaObjectHandler</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;开始插入填充...&quot;</span>);<br>        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">&quot;createTime&quot;</span>,<span class="hljs-keyword">new</span> Date(),metaObject);<br>        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">&quot;updateTime&quot;</span>,<span class="hljs-keyword">new</span> Date(),metaObject);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;开始更新填充...&quot;</span>);<br>        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">&quot;updateTime&quot;</span>,<span class="hljs-keyword">new</span> Date(),metaObject);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>乐观锁（OptimisticLockerInnerInterceptor）：当要更新一条记录的时候，希望这条记录没有被别人更新。</li></ol><ul><li>乐观锁实现方式：<blockquote><p>取出记录时，获取当前version<br>更新时，带上这个version<br>执行更新时， set version = newVersion where version = oldVersion<br>如果version不对，就更新失败</p></blockquote></li></ul><p>6.1 在数据库中添加version字段；<br>6.2 在实体类中同步更新；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Version</span><br><span class="hljs-keyword">private</span> Integer version;<br></code></pre></td></tr></table></figure><p>6.3 在配置类中写如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// Spring Boot 方式</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@MapperScan(&quot;按需修改&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisPlusConfig</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 旧版</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OptimisticLockerInterceptor <span class="hljs-title">optimisticLockerInterceptor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OptimisticLockerInterceptor();<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新版</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title">mybatisPlusInterceptor</span><span class="hljs-params">()</span> </span>&#123;<br>        MybatisPlusInterceptor mybatisPlusInterceptor = <span class="hljs-keyword">new</span> MybatisPlusInterceptor();<br>        mybatisPlusInterceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> OptimisticLockerInnerInterceptor());<br>        <span class="hljs-keyword">return</span> mybatisPlusInterceptor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>分页查询功能：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//Spring boot方式</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@MapperScan(&quot;com.baomidou.cloud.service.*.mapper*&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisPlusConfig</span> </span>&#123;<br><br>    <span class="hljs-comment">// 旧版</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PaginationInterceptor <span class="hljs-title">paginationInterceptor</span><span class="hljs-params">()</span> </span>&#123;<br>        PaginationInterceptor paginationInterceptor = <span class="hljs-keyword">new</span> PaginationInterceptor();<br>        <span class="hljs-comment">// 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求  默认false</span><br>        <span class="hljs-comment">// paginationInterceptor.setOverflow(false);</span><br>        <span class="hljs-comment">// 设置最大单页限制数量，默认 500 条，-1 不受限制</span><br>        <span class="hljs-comment">// paginationInterceptor.setLimit(500);</span><br>        <span class="hljs-comment">// 开启 count 的 join 优化,只针对部分 left join</span><br>        paginationInterceptor.setCountSqlParser(<span class="hljs-keyword">new</span> JsqlParserCountOptimize(<span class="hljs-keyword">true</span>));<br>        <span class="hljs-keyword">return</span> paginationInterceptor;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 最新版</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title">mybatisPlusInterceptor</span><span class="hljs-params">()</span> </span>&#123;<br>        MybatisPlusInterceptor interceptor = <span class="hljs-keyword">new</span> MybatisPlusInterceptor();<br>        interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> PaginationInnerInterceptor(DbType.H2));<br>        <span class="hljs-keyword">return</span> interceptor;<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-comment">//示例：</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPage</span><span class="hljs-params">()</span></span>&#123;<br>    Page&lt;User&gt; page = <span class="hljs-keyword">new</span> Page&lt;&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>);<br>    userMapper.selectPage(page,<span class="hljs-keyword">null</span>);<br>    page.getRecords().forEach(System.out::println);<br>    System.out.println(page.getTotal());<br>&#125;<br></code></pre></td></tr></table></figure><ol start="8"><li><p>逻辑删除功能：本质上是更新操作，使用@TableLogic注解加在实体类字段上。同时，执行查询操作的时候会自动过滤被逻辑删除的数据。</p></li><li><p>SQL分析打印：主要是对一些慢sql执行性能分析拦截。</p></li><li><p>条件构造器wrapper：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WrapperTest</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    UserMapper userMapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testNoNull</span><span class="hljs-params">()</span></span>&#123;<br>        QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();<br>        wrapper<br>                .isNotNull(<span class="hljs-string">&quot;name&quot;</span>)<br>                .isNotNull(<span class="hljs-string">&quot;email&quot;</span>)<br>                .ge(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">1</span>);<br>        userMapper.selectList(wrapper).forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="11"><li>代码生成器：主要分3步骤，首先是AutoGenerator mpg = new AutoGenerator();然后是各种配置，最后是mpg.execute();</li></ol>]]></content>
    
    
    <categories>
      
      <category>CRUD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>myBatis-plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis复习小结</title>
    <link href="/2021/08/04/Redis%E5%A4%8D%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/08/04/Redis%E5%A4%8D%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h4 id="第一，NoSQL"><a href="#第一，NoSQL" class="headerlink" title="第一，NoSQL"></a>第一，NoSQL</h4><p>Not only SQL，泛指非关系型数据库。不依赖业务逻辑方式存储，而以简单的key-value模式存储。目的是极大的增加数据库的拓展能力。常见的有Memcache，Redis和MongoDB</p><ul><li>不遵循SQL标准。</li><li>不支持ACID。（不是不支持事务）</li><li>远超于SQL的性能。</li></ul><p>适用场景：</p><ul><li>对数据高并发的读写。</li><li>海量数据的读写。</li><li>对数据高可扩展性的。</li></ul><p>不适用的场景：</p><ul><li>需要事务支持。</li><li>基于sql的结构化查询存储，处理复杂的关系,需要即席查询。</li></ul><h4 id="第二，Redis基本操作-redis-Link"><a href="#第二，Redis基本操作-redis-Link" class="headerlink" title="第二，Redis基本操作 redis-Link"></a>第二，Redis基本操作 <a href="http://www.redis.cn/commands.html">redis-Link</a></h4><p>默认端口号：6379</p><p>默认16个数据库，类似数组下标从0开始，初始默认使用0号库；使用命令 select n来切换数据库。</p><p>Redis是单线程+多路IO复用技术。其中单线程可以保证Redis操作的原子性，原子操作是指不会被线程调度机制打断的操作；</p><p>五大数据类型：String，List，Set，Hash，Zset</p><h5 id="key值的操作："><a href="#key值的操作：" class="headerlink" title="key值的操作："></a>key值的操作：</h5><blockquote><p>keys * //查看当前库所有key<br>set key value //设置key值与value<br>exists key //判断key是否存在<br>type key //查看key是什么类型<br>del key //删除指定的key数据<br>unlink key //根据value选择非阻塞删除<br>——仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。<br>expire key 10 10秒钟：//为给定的key设置过期时间<br>ttl key //查看还有多少秒过期，-1表示永不过期，-2表示已过期</p></blockquote><h5 id="库的选择："><a href="#库的选择：" class="headerlink" title="库的选择："></a>库的选择：</h5><blockquote><p>select //命令切换数据库<br>dbsize //查看当前数据库的key数量<br>flushdb //清空当前库<br>flushall //通杀全部库</p></blockquote><h5 id="string字符串"><a href="#string字符串" class="headerlink" title="string字符串"></a>string字符串</h5><ul><li>一个key对应一个value</li><li>二进制安全的，即可包含任何数据</li><li>value最多可以是512M。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</li><li>String的数据结构为简单动态字符串。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.</li></ul><blockquote><p>set key value //设置key值<br>get key //查询key值<br>append key value //将给定的value追加到原值末尾<br>strlen key //获取值的长度<br>setnx key value //只有在key不存在的时候，设置key值<br>incr key //将key值存储的数字增1，只对数字值操作，如果为空，新增值为1<br>decr key //将key值存储的数字减1，只对数字值操作，如果为空，新增值为1<br>decr key //将key值存储的数字减1<br>incrby/decrby key &lt;步长&gt; //将key值存储的数字增减如步长<br>mset key value key value…//同时设置一个或者多个key-value<br>mget key key…//同时获取一个或多个value<br>msetnx key value key value…// 同时设置一个或者多个key-value.当且仅当所有给定key都不存在<br>getrange key &lt;起始位置&gt; &lt;结束位置&gt; //获取key的起始位置和结束位置的值<br>setrange key &lt;起始位置&gt; value //将value的值覆盖起始位置开始<br>setex key &lt;&gt; value //设置键值的同时,设置过期时间<br>getset key value //用新值换旧值</p></blockquote><h5 id="list列表"><a href="#list列表" class="headerlink" title="list列表"></a>list列表</h5><ul><li><p>单键多值，值就是value，用List存储。</p></li><li><p>底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p></li><li><p>List的数据结构为快速链表quickList。首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p></li></ul><blockquote><p>lpush/rpush key value value…//从左或者右插入一个或者多个值(头插与尾插)<br>lpop/rpop key //从左或者右吐出一个或者多个值(值在键在,值都没,键都没)<br>rpoplpush key1 key2 //从key1列表右边吐出一个值,插入到key2的左边<br>lrange key start stop //按照索引下标获取元素(从左到右)<br>lrange key 0 -1 //获取所有值<br>lindex key index //按照索引下标获得元素<br>llen key //获取列表长度<br>linsert key before/after value newvalue //在value的前面插入一个新值<br>lrem key n value //从左边删除n个value值<br>lset key index value //在列表key中的下标index中修改值value</p></blockquote><h5 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h5><ul><li><p>Redis Set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p></li><li><p>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是O(1)。</p></li><li><p>Set数据结构是dict字典，字典是用哈希表实现的。Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p></li></ul><blockquote><p>sadd key value value… //将一个或者多个member元素加入集合key中,已经存在的member元素被忽略<br>smembers key //取出该集合的所有值<br>sismember key value //判断该集合key是否含有改值<br>scard key //返回该集合的元素个数<br>srem key value value //删除集合中的某个元素<br>spop key //随机从集合中取出一个元素<br>srandmember key n //随即从该集合中取出n个值，不会从集合中删除<br>smove &lt;一个集合a&gt;&lt;一个集合b&gt;value //将一个集合a的某个value移动到另一个集合b<br>sinter key1 key2 //返回两个集合的交集元素<br>sunion key1 key2 //返回两个集合的并集元素<br>sdiff key1 key2 //返回两个集合的差集元素（key1有的，key2没有）</p></blockquote><h5 id="hash哈希"><a href="#hash哈希" class="headerlink" title="hash哈希"></a>hash哈希</h5><ul><li><p>Redis hash 是一个键值对集合。Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。类似Java里面的Map&lt;String,Object&gt;</p></li><li><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p></li></ul><blockquote><p>hset key field value //给key集合中的filed键赋值value<br>hget key1 field //集合field取出value<br>hmset key1 field1 value1 field2 value2 //批量设置hash的值<br>hexists key1 field //查看哈希表key中，给定域field是否存在<br>hkeys key //列出该hash集合的所有field<br>hvals key //列出该hash集合的所有value<br>hincrby key field increment //为哈希表key中的域field的值加上增量1 -1<br>hsetnx key field value //将哈希表key中的域field的值设置为value，当且仅当域field不存在</p></blockquote><h5 id="Redis有序集合Zset-sorted-set"><a href="#Redis有序集合Zset-sorted-set" class="headerlink" title="Redis有序集合Zset(sorted set)"></a>Redis有序集合Zset(sorted set)</h5><ul><li><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。不同之处是有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了。因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p></li><li><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p></li><li><p>zset底层使用了两个数据结构:①hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。②跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</p></li></ul><blockquote><p>zadd key score1 value1 score2 value2 //将一个或多个member元素及其score值加入到有序key中<br>zrange key start stop (withscores) //返回有序集key，下标在start与stop之间的元素，带withscores，可以让分数一起和值返回到结果集。<br>zrangebyscore key min max(withscores) //返回有序集key，所有score值介于min和max之间（包括等于min或max）的成员。有序集成员按score的值递增次序排列<br>zrevrangebyscore key max min （withscores）//同上，改为从大到小排列<br>zincrby key increment value //为元素的score加上增量<br>zrem key value //删除该集合下，指定值的元素<br>zcount key min max //统计该集合，分数区间内的元素个数<br>zrank key value //返回该值在集合中的排名，从0开始</p></blockquote><h4 id="第三，Redis配置文件"><a href="#第三，Redis配置文件" class="headerlink" title="第三，Redis配置文件"></a>第三，Redis配置文件</h4><ul><li><p>配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit</p></li><li><p>大小写不敏感</p></li><li><p>默认情况bind=127.0.0.1只能接受本机的访问请求，不写的情况下，无限制接受任何ip地址的访问。生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其注释掉(bind 127.0.0.1)。如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应。protected-mode no</p></li><li><p>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值（128），所以需要确认增大/proc/sys/net/core/somaxconn和/proc/sys/net/ipv4/tcp_max_syn_backlog（128）两个值来达到想要的效果。tcp-backlog 511</p></li><li><p>一个空闲的客户端维持多少秒会关闭，timeout 0表示关闭该功能。即永不关闭。</p></li><li><p>对访问客户端的一种心跳检测，每个n秒检测一次。单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60。tcp-keepalive 60</p></li><li><p>是否为后台进程，设置为daemonize yes。守护进程，后台启动</p></li><li><p>pidfile：存放pid文件的位置，每个实例会产生一个不同的pid文件</p></li><li><p>loglevel notice。指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为notice。四个级别根据使用阶段来选择，生产环境选择notice 或者warning</p></li><li><p>日志文件名称：logfile “”</p></li><li><p>databases 16。设定库的数量 默认16，默认数据库为0，可以使用SELECT n命令在连接上指定数据库id</p></li><li><p>maxclients：10000。设置redis同时可以与多少个客户端进行连接。默认情况下为10000个客户端。如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</p></li><li><p>maxmemory &lt;bytes&gt; 。建议必须设置，否则，将内存占满，造成服务器宕机。设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p></li><li><p>maxmemory-policy xxxxxx。</p><ul><li>volatile-lru：使用LRU算法移除key，只对设置了过期时间的键；（最近最少使用）；</li><li>allkeys-lru：在所有集合key中，使用LRU算法移除key</li><li>volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键</li><li>allkeys-random：在所有集合key中，移除随机的key</li><li>volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key</li><li>noeviction：不进行移除。针对写操作，只是返回错误信息</li></ul></li><li><p>maxmemory-samples 5 。设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个。一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小。</p></li></ul><h4 id="第四，Redis发布和订阅"><a href="#第四，Redis发布和订阅" class="headerlink" title="第四，Redis发布和订阅"></a>第四，Redis发布和订阅</h4><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。Redis 客户端可以订阅任意数量的频道。</p><p>例如：</p><ul><li><p>SUBSCRIBE channel1 订阅频道1</p></li><li><p>publish channel1 hello 向频道1发送hello</p></li></ul><h4 id="第五，Redis新数据类型"><a href="#第五，Redis新数据类型" class="headerlink" title="第五，Redis新数据类型"></a>第五，Redis新数据类型</h4><h5 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h5><ul><li>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：<ul><li>Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</li><li>Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</li><li>很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。</li></ul></li></ul><blockquote><p>setbit key offset value设置Bitmaps中某个偏移量的值（0或1）。offset:偏移量从0开始</p></blockquote><blockquote><p>getbit key offset 获取Bitmaps中某个偏移量的值,获取键的第offset位的值（从0开始算）</p><p>bitcount key （start end）统计字符串被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。注意：redis的setbit设置或清除的是bit位置，而bitcount计算的是byte位置。</p><p>bitop and(or/not/xor）destkey key bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。</p></blockquote><ul><li>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户,很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的。但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0。</li></ul><h4 id="第六，HyperLogLog"><a href="#第六，HyperLogLog" class="headerlink" title="第六，HyperLogLog"></a>第六，HyperLogLog</h4><p>经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。</p><ul><li>数据存储在MySQL表中，使用distinct count计算不重复个数</li><li>使用Redis提供的hash、set、bitmaps等数据结构来处理</li></ul><p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog。Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><blockquote><p>pfdd key element 添加指定的元素到hyperloglog中<br>pfcount key 计算key的近似基数,即这个key的键位添加了多少个不重复元素<br>pfmerge destkey sourcekey sourcekey 一个或多个key合并后的结果存在另一个key</p></blockquote><h4 id="第七，Geospatial"><a href="#第七，Geospatial" class="headerlink" title="第七，Geospatial"></a>第七，Geospatial</h4><p>提供经纬度设置，查询范围，距离查询等。</p><blockquote><p>geoadd key longitude latitude member 添加地理位置（经度纬度名称）geoadd china:city 121.47 31.23 shanghai</p><p>geopos key member 获取指定地区的坐标值</p><p>geodist key member1 member2 (m km ft mi) 获取两个位置之间的直线距离</p><p>georadius key longitude latitude radius (m km ft mi) 以给定的经纬度为中心，找出某一半径的内元素</p></blockquote><h4 id="第八，Jedis操作Redis"><a href="#第八，Jedis操作Redis" class="headerlink" title="第八，Jedis操作Redis"></a>第八，Jedis操作Redis</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">jedis</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br><br>        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br><br>        jedis.auth(<span class="hljs-string">&quot;123456&quot;</span>);<br>        System.out.println(jedis.getClient().getPort());<br>        System.out.println(<span class="hljs-string">&quot;连接本地的Redis服务器成功&quot;</span>);<br>        <span class="hljs-comment">//查看服务是否运行</span><br>        System.out.println(<span class="hljs-string">&quot;服务正在运行：&quot;</span> + jedis.ping());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="操作Keys"><a href="#操作Keys" class="headerlink" title="操作Keys"></a>操作Keys</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java">jedis.set(<span class="hljs-string">&quot;k1&quot;</span>, <span class="hljs-string">&quot;v1&quot;</span>);<br>jedis.set(<span class="hljs-string">&quot;k2&quot;</span>, <span class="hljs-string">&quot;v2&quot;</span>);<br>jedis.set(<span class="hljs-string">&quot;k3&quot;</span>, <span class="hljs-string">&quot;v3&quot;</span>);<br>Set&lt;String&gt; keys = jedis.keys(<span class="hljs-string">&quot;*&quot;</span>);<br>System.out.println(keys.size());<br><span class="hljs-keyword">for</span> (String key : keys) &#123;<br>System.out.println(key);<br>&#125;<br>System.out.println(jedis.exists(<span class="hljs-string">&quot;k1&quot;</span>));<br>System.out.println(jedis.ttl(<span class="hljs-string">&quot;k1&quot;</span>));                <br>System.out.println(jedis.get(<span class="hljs-string">&quot;k1&quot;</span>));<br></code></pre></td></tr></table></figure><h5 id="String测试代码"><a href="#String测试代码" class="headerlink" title="String测试代码"></a>String测试代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">jedis.mset(<span class="hljs-string">&quot;str1&quot;</span>,<span class="hljs-string">&quot;v1&quot;</span>,<span class="hljs-string">&quot;str2&quot;</span>,<span class="hljs-string">&quot;v2&quot;</span>,<span class="hljs-string">&quot;str3&quot;</span>,<span class="hljs-string">&quot;v3&quot;</span>);<br>System.out.println(jedis.mget(<span class="hljs-string">&quot;str1&quot;</span>,<span class="hljs-string">&quot;str2&quot;</span>,<span class="hljs-string">&quot;str3&quot;</span>));<br></code></pre></td></tr></table></figure><h5 id="List测试代码"><a href="#List测试代码" class="headerlink" title="List测试代码"></a>List测试代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java">List&lt;String&gt; list = jedis.lrange(<span class="hljs-string">&quot;mylist&quot;</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (String element : list) &#123;<br>System.out.println(element);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Set测试代码"><a href="#Set测试代码" class="headerlink" title="Set测试代码"></a>Set测试代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java">jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order01&quot;</span>);<br>jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order02&quot;</span>);<br>jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order03&quot;</span>);<br>jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order04&quot;</span>);<br>Set&lt;String&gt; smembers = jedis.smembers(<span class="hljs-string">&quot;orders&quot;</span>);<br><span class="hljs-keyword">for</span> (String order : smembers) &#123;<br>System.out.println(order);<br>&#125;<br>jedis.srem(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order02&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="Hash测试代码"><a href="#Hash测试代码" class="headerlink" title="Hash测试代码"></a>Hash测试代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java">jedis.hset(<span class="hljs-string">&quot;hash1&quot;</span>,<span class="hljs-string">&quot;userName&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>);<br>System.out.println(jedis.hget(<span class="hljs-string">&quot;hash1&quot;</span>,<span class="hljs-string">&quot;userName&quot;</span>));<br>Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String,String&gt;();<br>map.put(<span class="hljs-string">&quot;telphone&quot;</span>,<span class="hljs-string">&quot;13810169999&quot;</span>);<br>map.put(<span class="hljs-string">&quot;address&quot;</span>,<span class="hljs-string">&quot;atguigu&quot;</span>);<br>map.put(<span class="hljs-string">&quot;email&quot;</span>,<span class="hljs-string">&quot;abc@163.com&quot;</span>);<br>jedis.hmset(<span class="hljs-string">&quot;hash2&quot;</span>,map);<br>List&lt;String&gt; result = jedis.hmget(<span class="hljs-string">&quot;hash2&quot;</span>, <span class="hljs-string">&quot;telphone&quot;</span>,<span class="hljs-string">&quot;email&quot;</span>);<br><span class="hljs-keyword">for</span> (String element : result) &#123;<br>System.out.println(element);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Zset测试代码"><a href="#Zset测试代码" class="headerlink" title="Zset测试代码"></a>Zset测试代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java">jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">100d</span>, <span class="hljs-string">&quot;z3&quot;</span>);<br>jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">90d</span>, <span class="hljs-string">&quot;l4&quot;</span>);<br>jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">80d</span>, <span class="hljs-string">&quot;w5&quot;</span>);<br>jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">70d</span>, <span class="hljs-string">&quot;z6&quot;</span>);<br> <br>Set&lt;String&gt; zrange = jedis.zrange(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (String e : zrange) &#123;<br>System.out.println(e);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第九，Redis与Spring-Boot整合"><a href="#第九，Redis与Spring-Boot整合" class="headerlink" title="第九，Redis与Spring Boot整合"></a>第九，Redis与Spring Boot整合</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- redis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml">#Redis服务器地址<br>spring.redis.host=192.168.xxx.xxx<br>#Redis服务器连接端口<br>spring.redis.port=6379<br>#Redis数据库索引（默认为0）<br>spring.redis.database= 0<br>#连接超时时间（毫秒）<br>spring.redis.timeout=1800000<br>#连接池最大连接数（使用负值表示没有限制）<br>spring.redis.lettuce.pool.max-active=20<br>#最大阻塞等待时间(负数表示没限制)<br>spring.redis.lettuce.pool.max-wait=-1<br>#连接池中的最大空闲连接<br>spring.redis.lettuce.pool.max-idle=5<br>#连接池中的最小空闲连接<br>spring.redis.lettuce.pool.min-idle=0<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CachingConfigurerSupport</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> </span>&#123;<br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();<br>        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object.class);<br>        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>        template.setConnectionFactory(factory);<br><span class="hljs-comment">//key序列化方式</span><br>        template.setKeySerializer(redisSerializer);<br><span class="hljs-comment">//value序列化</span><br>        template.setValueSerializer(jackson2JsonRedisSerializer);<br><span class="hljs-comment">//value hashmap序列化</span><br>        template.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">(RedisConnectionFactory factory)</span> </span>&#123;<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();<br>        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object.class);<br><span class="hljs-comment">//解决查询缓存转换异常的问题</span><br>        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br><span class="hljs-comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span><br>        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()<br>                .entryTtl(Duration.ofSeconds(<span class="hljs-number">600</span>))<br>                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))<br>                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))<br>                .disableCachingNullValues();<br>        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)<br>                .cacheDefaults(config)<br>                .build();<br>        <span class="hljs-keyword">return</span> cacheManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/redisTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisTestController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testRedis</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//设置值到redis</span><br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;lucy&quot;</span>);<br>        <span class="hljs-comment">//从redis获取值</span><br>        String name = (String)redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第十，Redis的事务操作"><a href="#第十，Redis的事务操作" class="headerlink" title="第十，Redis的事务操作"></a>第十，Redis的事务操作</h4><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。Redis事务的主要作用就是串联多个命令防止别的命令插队。</p><ol><li>Multi、Exec、discard</li></ol><ul><li>从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。组队的过程中可以通过discard来放弃组队</li><li>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消；</li><li>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚；</li></ul><ol start="2"><li>事务冲突</li></ol><ul><li>悲观锁：不能同时进行多人，执行的时候先上锁。悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</li><li>乐观锁：通过版本号一致与否，即给数据加上版本，同步更新数据以及加上版本号。不会上锁，判断版本号，可以多人操作，类似生活中的抢票。乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。Redis就是利用这种check-and-set机制实现事务的。在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</li><li>unwatch：取消 WATCH 命令对所有 key 的监视。如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。</li></ul><ol start="3"><li>Redis事务三特性</li></ol><ul><li>单独的隔离操作：<ul><li>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li></ul></li><li>没有隔离级别的概念<ul><li>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</li></ul></li><li>不保证原子性<ul><li>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li></ul></li></ul><h4 id="第十一，Redis持久化之RDB与AOF"><a href="#第十一，Redis持久化之RDB与AOF" class="headerlink" title="第十一，Redis持久化之RDB与AOF"></a>第十一，Redis持久化之RDB与AOF</h4><p>Redis 提供了2个不同形式的持久化方式：RDB（Redis DataBase）和AOF（Append Of File）</p><h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h5><ul><li>在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</li><li>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</li><li>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“写时复制技术”。一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</li></ul><ol><li>在redis.conf中配置文件名称，默认为dump.rdb</li><li>rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下<br>dir “/myredis/“</li><li>save ：save时只管保存，其它不管，全部阻塞。手动保存。不建议。</li><li>bgsave：Redis会在后台异步进行快照操作， 快照同时还可以响应客户端请求。</li><li>可以通过lastsave 命令获取最后一次成功执行快照的时间</li><li>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</li><li>stop-writes-on-bgsave-error：当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes.</li><li>rdbcompression 压缩文件：对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes.</li><li>12.2.8.8.rdbchecksum 检查完整性：在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。推荐yes.</li><li>rdb的备份：先通过config get dir  查询rdb文件的目录，将*.rdb的文件拷贝到别的地方；</li><li>rdb的恢复：关闭Redis；先把备份的文件拷贝到工作目录下 cp dump2.rdb dump.rdb；启动Redis, 备份数据会直接加载</li><li>动态停止RDB：redis-cli config set save “”#save后给空值，表示禁用保存策略</li></ol><ul><li>优势：<ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高更适合使用</li><li>节省磁盘空间</li><li>恢复速度快</li></ul></li><li>劣势：<ul><li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li><li>虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。</li><li>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</li></ul></li></ul><h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h5><ul><li>以日志的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(读操作不记录)， 只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</li><li>AOF持久化流程：<ul><li>客户端的请求写命令会被append追加到AOF缓冲区内；</li><li>AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中</li><li>AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；</li><li>Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的；</li></ul></li><li>可以在redis.conf中配置文件名称，默认为 appendonly.aof。AOF文件的保存路径，同RDB的路径一致。</li><li>AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）</li><li>AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</li><li>正常恢复：<ul><li>修改默认的appendonly no，改为yes</li><li>将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir)</li><li>恢复：重启redis然后重新加载</li></ul></li><li>异常恢复：<ul><li>修改默认的appendonly no，改为yes</li><li>如遇到AOF文件损坏，通过/usr/local/bin/redis-check-aof–fix appendonly.aof进行恢复</li><li>备份被写坏的AOF文件</li><li>恢复：重启redis，然后重新加载</li></ul></li><li>AOF同步频率设置：<ul><li>appendfsync always：始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好</li><li>appendfsync everysec：每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</li><li>appendfsync no：redis不主动进行同步，把同步时机交给操作系统。</li></ul></li><li>Rewrite压缩：AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集。可以使用命令bgrewriteaof<ul><li>重写原理，如何实现重写：AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。</li><li>no-appendfsync-on-rewrite：如果 no-appendfsync-on-rewrite=yes ,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）。如果 no-appendfsync-on-rewrite=no,  还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）</li><li>触发机制，何时重写：Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。</li><li>auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）</li><li>auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,如果Redis的AOF当前大小&gt;= base_size +base_size*100% (默认)且当前大小&gt;=64mb(默认)的情况下，Redis会对AOF进行重写。</li><li>重写流程：<ul><li>bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。</li><li>主进程fork出子进程执行重写操作，保证主进程不会阻塞。</li><li>子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。</li><li>1).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。2).主进程把aof_rewrite_buf中的数据写入到新的AOF文件。</li><li>使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</li></ul></li></ul></li><li>优势：<ul><li>备份机制更稳健，丢失数据概率更低。</li><li>可读的日志文本，通过操作AOF稳健，可以处理误操作。</li></ul></li><li>劣势：<ul><li>比起RDB占用更多的磁盘空间。</li><li>恢复备份速度要慢。</li><li>每次读写都同步的话，有一定的性能压力。</li><li>存在个别Bug，造成恢复不能</li></ul></li></ul><p>总结对比RDB和AOF：</p><ol><li>官方推荐两个都启用。如果对数据不敏感，可以选单独用RDB。不建议单独用 AOF，因为可能会出现Bug。如果只是做纯内存缓存，可以都不用。</li><li>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</li><li>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾. </li><li>Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大</li><li>只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式</li><li>同时开启两种持久化方式</li><li>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li><li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ 建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</li><li>性能建议<ol><li> 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则</li><li> 如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了</li><li> 代价,一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的</li><li> 只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。</li><li> 默认超过原大小100%大小时重写可以改到适当的数值。</li></ol></li></ol><h4 id="第十二，Redis-主从复制"><a href="#第十二，Redis-主从复制" class="headerlink" title="第十二，Redis_主从复制"></a>第十二，Redis_主从复制</h4><p>主机数据更新后根据配置和策略， 自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主。读写分离，性能扩展。容灾快速恢复。</p><ul><li>主从复制的思路：<ul><li>拷贝多个redis.conf文件include(写绝对路径)</li><li>开启daemonize yes</li><li>Pid文件名字pidfile</li><li>指定端口port</li><li>Log文件名字</li><li>dump.rdb名字dbfilename</li><li>Appendonly 关掉或者换名字</li></ul></li><li>具体操作：新建redis6379.conf，填写以下内容：<ul><li>include /myredis/redis.conf</li><li>pidfile /var/run/redis_6379.pid</li><li>port 6379</li><li>dbfilename dump6379.rdb</li></ul></li><li>新建redis6380.conf，填写内容和上面类似</li><li>新建redis6381.conf，填写内容和上面类似</li><li>slave-priority 10。设置从机的优先级，值越小，优先级越高，用于选举主机时使用。默认100</li><li>启动三台redis服务器，redis-server redis6379.conf，以此类推</li><li>查看系统进程，看看三台服务器是否启动：-ef|grep redis</li><li>查看三台主机运行情况：info replication打印主从复制的相关信息</li><li>配从(库)不配主(库)：slaveof  &lt;ip&gt;&lt;port&gt;成为某个实例的从服务器<ul><li>在6380和6381上执行: slaveof 127.0.0.1 6379</li><li>在主机上写，在从机上可以读取数据</li><li>主机挂掉，重启就行，一切如初。redis-server redis6379.conf然后redis-cli -p 6379</li><li>从机重启需重设：slaveof 127.0.0.1 6379。可以将配置增加到文件中。永久生效。</li></ul></li></ul><hr><ul><li>常用的三个解决办法：<ul><li>切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的k1,k2,k3是否也可以复制？从机是否可以写？set可否？主机shutdown后情况如何？从机是上位还是原地待命？主机又回来了后，主机新增记录，从机还能否顺利复制？其中一台从机down后情况如何？依照原有它能跟上大部队吗？</li><li>方法一：一主二仆：</li><li>方法二：薪火相传；上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。用 slaveof  &lt;ip&gt;&lt;port&gt;.中途变更转向:会清除之前的数据，重新建立拷贝最新的。风险是一旦某个slave宕机，后面的slave都没法备份。主机挂了，从机还是从机，无法写数据了。</li><li>方法三：反客为主；当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。用 slaveof  no one  将从机变为主机</li></ul></li><li>主从复制原理：<ul><li>Slave启动成功连接到master后会发送一个sync命令</li><li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步</li><li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li><li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</li><li>但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</li></ul></li></ul><hr><ul><li><p>哨兵原理：</p><ul><li>反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</li><li>步骤：<ul><li>调整为一主二仆模式，6379带着6380、6381</li><li>自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错</li><li>配置哨兵,填写内容：sentinel monitor mymaster 127.0.0.1 6379 1其中mymaster为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量。</li><li>启动哨兵：/usr/local/bin，redis做压测可以用自带的redis-benchmark工具，执行redis-sentinel  /myredis/sentinel.conf </li><li>当主机挂掉，从机选举中产生新的主机：(大概10秒左右可以看到哨兵窗口日志，切换了新的主机)，哪个从机会被选举为主机呢？根据优先级别：slave-priority ，原主机重启后会变为从机。</li><li>复制延时：由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</li></ul></li></ul></li><li><p>故障恢复：</p><ul><li>优先级在redis.conf中默认：slave-priority 100，值越小优先级越高。偏移量是指获得原主机数据最全的。每个redis实例启动后都会随机生成一个40位的runid</li></ul></li><li><p>主从复制： </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisSentinelPool jedisSentinelPool=<span class="hljs-keyword">null</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  Jedis <span class="hljs-title">getJedisFromSentinel</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">if</span>(jedisSentinelPool==<span class="hljs-keyword">null</span>)&#123;<br>    Set&lt;String&gt; sentinelSet=<span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    sentinelSet.add(<span class="hljs-string">&quot;192.168.11.103:26379&quot;</span>);<br><br>    JedisPoolConfig jedisPoolConfig =<span class="hljs-keyword">new</span> JedisPoolConfig();<br>    jedisPoolConfig.setMaxTotal(<span class="hljs-number">10</span>); <span class="hljs-comment">//最大可用连接数</span><br>    jedisPoolConfig.setMaxIdle(<span class="hljs-number">5</span>); <span class="hljs-comment">//最大闲置连接数</span><br>    jedisPoolConfig.setMinIdle(<span class="hljs-number">5</span>); <span class="hljs-comment">//最小闲置连接数</span><br>    jedisPoolConfig.setBlockWhenExhausted(<span class="hljs-keyword">true</span>); <span class="hljs-comment">//连接耗尽是否等待</span><br>    jedisPoolConfig.setMaxWaitMillis(<span class="hljs-number">2000</span>); <span class="hljs-comment">//等待时间</span><br>    jedisPoolConfig.setTestOnBorrow(<span class="hljs-keyword">true</span>); <span class="hljs-comment">//取连接的时候进行一下测试 ping pong</span><br><br>jedisSentinelPool=<span class="hljs-keyword">new</span> JedisSentinelPool(<span class="hljs-string">&quot;mymaster&quot;</span>,sentinelSet,jedisPoolConfig);<br><span class="hljs-keyword">return</span> jedisSentinelPool.getResource();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> jedisSentinelPool.getResource();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="第十三，Redis集群"><a href="#第十三，Redis集群" class="headerlink" title="第十三，Redis集群"></a>第十三，Redis集群</h4><p>容量不够，redis如何进行扩容？并发写操作， redis如何分摊？另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。之前通过代理主机来解决，但是redis3.0中提供了解决方案。就是无中心化集群配置。</p><p>什么是集群：Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p><ul><li><p>删除持久化数据：将rdb,aof文件都删除掉</p></li><li><p>制作6个实例，6379,6380,6381,6389,6390,6391</p><ul><li>配置基本信息：<ul><li>开启daemonize yes</li><li>Pid文件名字</li><li>指定端口</li><li>Log文件名字</li><li>Dump.rdb名字</li><li>Appendonly 关掉或者换名字</li></ul></li><li>redis cluster配置修改：<ul><li>cluster-enabled yes    打开集群模式</li><li>cluster-config-file nodes-6379.conf  设定节点配置文件名</li><li>cluster-node-timeout 15000   设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。</li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java">include /home/bigdata/redis.conf<br>port <span class="hljs-number">6379</span><br>pidfile <span class="hljs-string">&quot;/var/run/redis_6379.pid&quot;</span><br>dbfilename <span class="hljs-string">&quot;dump6379.rdb&quot;</span><br>dir <span class="hljs-string">&quot;/home/bigdata/redis_cluster&quot;</span><br>logfile <span class="hljs-string">&quot;/home/bigdata/redis_cluster/redis_err_6379.log&quot;</span><br>cluster-enabled yes<br>cluster-config-file nodes-<span class="hljs-number">6379.</span>conf<br>cluster-node-timeout <span class="hljs-number">15000</span><br></code></pre></td></tr></table></figure></li></ul></li><li>修改好redis6379.conf文件，拷贝多个redis.conf文件</li><li>使用查找替换修改另外5个文件，例如：:%s/6379/6380</li><li>启动6个redis服务，例如redis-server redis6379.conf</li><li>六个节点合成一个集群：组合之前，请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。</li><li>合体：cd  /opt/redis-6.2.1/src</li><li>```Java<br>redis-cli –cluster create –cluster-replicas 1 192.168.11.101:6379 192.168.11.101:6380 192.168.11.101:6381 192.168.11.101:6389 192.168.11.101:6390 192.168.11.101:6391<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">- 此处不要用<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>， 请用真实IP地址。-replicas <span class="hljs-number">1</span> 采用最简单的方式配置集群，一台主机，一台从机，正好三组。配置成功后显示<span class="hljs-number">16384</span> slots covered<br>- 普通方式登录：可能直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，应该以集群方式登录。<br>- -c 采用集群策略连接，设置数据会自动切换到相应的写主机。redis-cli -c -p <span class="hljs-number">6379</span><br>- 通过 <span class="hljs-keyword">cluster</span> nodes 命令查看集群信息。<br>- redis <span class="hljs-keyword">cluster</span> 如何分配这六个节点？<br>  - 一个集群至少要有三个主节点。<br>  - 选项 <span class="hljs-comment">--cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。</span><br>  - 分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。<br>- 什么是slots？插槽的意思。<span class="hljs-number">0</span>~<span class="hljs-number">16383</span><br>  - 一个 Redis 集群包含 <span class="hljs-number">16384</span> 个插槽（hash slot）， 数据库中的每个键都属于这 <span class="hljs-number">16384</span> 个插槽的其中一个。集群使用公式 CRC16(key) % <span class="hljs-number">16384</span> 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和。集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点，其中：节点 A 负责处理 <span class="hljs-number">0</span> 号至 <span class="hljs-number">5460</span> 号插槽。节点 B 负责处理 <span class="hljs-number">5461</span> 号至 <span class="hljs-number">10922</span> 号插槽。节点 C 负责处理 <span class="hljs-number">10923</span> 号至 <span class="hljs-number">16383</span> 号插槽。<br>- 在集群中录入值：<br>  - 在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。<br>  - redis-cli客户端提供了 –c 参数实现自动重定向。<br>  - 如 redis-cli  -c –p <span class="hljs-number">6379</span> 登入后，再录入、查询键值对可以自动重定向。<br>  - 不在一个slot下的键值，是不能使用mget,mset等多键操作。<br>  - 可以通过&#123;&#125;来定义组的概念，从而使key中&#123;&#125;内相同内容的键值对放到一个slot中去。例如mset <span class="hljs-type">name</span>&#123;<span class="hljs-keyword">user</span>&#125; xxx age&#123;<span class="hljs-keyword">user</span>&#125; <span class="hljs-number">20</span><br>- 查询集群中的值：<br>  - <span class="hljs-keyword">CLUSTER</span> GETKEYSINSLOT &lt;slot&gt;&lt;count&gt; 返回 count 个 slot 槽中的键。<br>- 故障恢复：<br>  - 如果主节点下线？从节点能否自动升为主节点？注意：<span class="hljs-number">15</span>秒超时<br>  - 主节点恢复后，主从关系会如何？主节点回来变成从机。<br>  - 如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?<br>  - 如果某一段插槽的主从都挂掉，而<span class="hljs-keyword">cluster</span>-require-<span class="hljs-keyword">full</span>-coverage 为yes ，那么 ，整个集群都挂掉<br>  - 如果某一段插槽的主从都挂掉，而<span class="hljs-keyword">cluster</span>-require-<span class="hljs-keyword">full</span>-coverage 为<span class="hljs-keyword">no</span> ，那么，该插槽数据全都不能使用，也无法存储。<br>  - redis.conf中的参数  <span class="hljs-keyword">cluster</span>-require-<span class="hljs-keyword">full</span>-coverage<br>- 集群的Jedis开发：<br>  - 即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。<br>  - 无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。<br>  - ```Java<br>    <span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> JedisClusterTest &#123;<br>      <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123; <br>        <span class="hljs-keyword">Set</span>&lt;HostAndPort&gt;<span class="hljs-keyword">set</span> =<span class="hljs-built_in">new</span> HashSet&lt;HostAndPort&gt;();<br>        <span class="hljs-keyword">set</span>.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> HostAndPort(&quot;192.168.xx.xxx&quot;,<span class="hljs-number">6379</span>));<br>        JedisCluster jedisCluster=<span class="hljs-built_in">new</span> JedisCluster(<span class="hljs-keyword">set</span>);<br>        jedisCluster.<span class="hljs-keyword">set</span>(&quot;k1&quot;, &quot;v1&quot;);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(jedisCluster.<span class="hljs-keyword">get</span>(&quot;k1&quot;));<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Redis 集群提供了以下好处:</p><ul><li>实现扩容</li><li>分摊压力</li><li>无中心配置相对简单</li></ul></li><li><p>Redis 集群的不足:</p><ul><li>多键操作是不被支持的</li><li>多键的Redis事务是不被支持的。lua脚本不被支持</li><li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</li></ul></li></ul><h4 id="第十四，Redis应用问题解决"><a href="#第十四，Redis应用问题解决" class="headerlink" title="第十四，Redis应用问题解决"></a>第十四，Redis应用问题解决</h4><h5 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h5><ul><li>key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</li><li>解决方案:一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。<ul><li>对空值缓存：如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</li><li>设置可访问的名单（白名单）：使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</li><li>采用布隆过滤器：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。</li><li>进行实时监控：当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</li></ul></li></ul><h5 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h5><ul><li>某个key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</li><li>解决方案:key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。<ul><li>预先设置热门数据：在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长</li><li>实时调整：现场监控哪些数据热门，实时调整key的过期时长</li><li>使用锁：<ul><li>就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</li><li>先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key.</li><li>当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；</li><li>当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</li></ul></li></ul></li></ul><h5 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h5><ul><li>在极小的时间段内，查询大量key的集中过期情况。缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，后者则是某一个key</li><li>解决方案:缓存失效时的雪崩效应对底层系统的冲击非常可怕！<ul><li>构建多级缓存架构：nginx缓存 + redis缓存 +其他缓存（ehcache等）</li><li>使用锁或队列：<ul><li>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况</li></ul></li><li>设置过期标志更新缓存：记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</li><li>将缓存失效时间分散开：比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</li></ul></li></ul><h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h5><ul><li><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p></li><li><p>分布式锁主流的实现方案：</p><ul><li>基于数据库实现分布式锁</li><li>基于缓存（Redis等）</li><li>基于Zookeeper</li></ul></li><li><p>每一种分布式锁解决方案都有各自的优缺点：</p><ul><li>性能：redis最高</li><li>可靠性：zookeeper最高</li></ul></li><li><p>解决方案：使用redis实现分布式锁</p><ul><li><p>redis:命令，例如setnx users 100就加上锁了，释放锁 del users。如果想同时操作，保持原子性，那么就例如set users 10 nx ex 20</p><ul><li># set sku:1:info “OK” NX PX 10000</li><li>EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value </li><li>PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。</li><li>NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</li><li>XX ：只在键已经存在时，才对键进行设置操作。</li></ul></li><li><p>备注：</p><ul><li>多个客户端同时获取锁（setnx）</li><li>获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</li><li>其他客户端等待重试</li></ul></li><li><p>Redis: set num 0 测试代码</p></li><li><pre><code class="Java">@GetMapping(&quot;testLock&quot;)public void testLock()&#123;    //1获取锁，setne    Boolean lock = redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;111&quot;);    //2获取锁成功、查询num的值    if(lock)&#123;        Object value = redisTemplate.opsForValue().get(&quot;num&quot;);        //2.1判断num为空return        if(StringUtils.isEmpty(value))&#123;            return;        &#125;        //2.2有值就转成成int        int num = Integer.parseInt(value+&quot;&quot;);        //2.3把redis的num加1        redisTemplate.opsForValue().set(&quot;num&quot;, ++num);        //2.4释放锁，del        redisTemplate.delete(&quot;lock&quot;);    &#125;else&#123;        //3获取锁失败、每隔0.1秒再获取        try &#123;            Thread.sleep(100);            testLock();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><ul><li>重启，服务集群，通过网关压力测试：</li><li>ab -n 1000 -c 100 <a href="http://192.168.2.80:8080/redisTest/testLock">http://192.168.2.80:8080/redisTest/testLock</a></li><li>查看redis中num的值：</li><li>基本实现。</li><li>问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放<ul><li>解决：在redisTemplate.opsForValue().setIfAbsent(添加参数)，设置过期时间，自动释放锁。</li></ul></li></ul></li><li><p>优化之设置锁的过期时间：设置过期时间有两种方式：</p><ul><li>首先想到通过expire设置过期时间（缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放）</li><li>在set时指定过期时间（推荐）</li></ul></li><li><p>但这样的方式还是有错误释放锁的问题，需要考虑下面两个方面：</p><ul><li>优化之UUID防误删：意思是不要误释放了别人的锁，用uuid表示不同的操作，sel lock uuid nx ex 10。在释放锁的时候，首先判断当前uuid和要释放的uuid是否一样。</li><li>优化之LUA脚本保证删除的原子性：因为LUA脚本支持原子性操作。</li></ul></li><li><p>为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p><ul><li>互斥性。在任意时刻，只有一个客户端能持有锁</li><li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁</li><li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li><li>加锁和解锁必须具有原子性</li></ul></li></ul></li></ul><h4 id="第十五，Redis6-0新功能"><a href="#第十五，Redis6-0新功能" class="headerlink" title="第十五，Redis6.0新功能"></a>第十五，Redis6.0新功能</h4><h5 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h5><ul><li>Redis ACL是Access Control List（访问控制列表）的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接。</li><li>在Redis 5版本之前，Redis 安全规则只有密码控制 还有通过rename 来调整高危命令比如 flushdb ， KEYS* ， shutdown 等。Redis 6 则提供ACL的功能对用户进行更细粒度的权限控制 ：<ul><li>接入权限:用户名和密码</li><li>可以执行的命令 </li><li>可以操作的 KEY</li></ul></li></ul><h5 id="IO多线程"><a href="#IO多线程" class="headerlink" title="IO多线程"></a>IO多线程</h5><ul><li>IO多线程其实指客户端交互部分的网络IO交互处理模块多线程，而非执行命令多线程。Redis6执行命令依然是单线程。</li><li>Redis 6 加入多线程,但跟 Memcached 这种从 IO处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题。</li><li>另外，多线程IO默认也是不开启的，需要再配置文件中配置<ul><li>io-threads-do-reads  yes </li><li>io-threads 4</li></ul></li></ul><h5 id="工具支持-Cluster"><a href="#工具支持-Cluster" class="headerlink" title="工具支持 Cluster"></a>工具支持 Cluster</h5><ul><li>之前老版Redis想要搭集群需要单独安装ruby环境，Redis 5 将 redis-trib.rb 的功能集成到 redis-cli 。另外官方 redis-benchmark 工具开始支持 cluster 模式了，通过多线程的方式对多个分片进行压测。</li></ul>]]></content>
    
    
    <categories>
      
      <category>缓存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
